# 2ステップ抽出方式（分割推定方式）機能提案書

## ドキュメント情報

- **作成日**: 2025-11-15
- **最終更新**: 2025-11-15 16:14
- **バージョン**: 1.0
- **ドキュメント種別**: 機能提案書

---

## 目次

1. [提案概要](#提案概要)
2. [現状の課題](#現状の課題)
3. [提案する手法の概念](#提案する手法の概念)
4. [処理フロー](#処理フロー)
5. [メリット](#メリット)
6. [デメリット](#デメリット)
7. [適用シーン](#適用シーン)
8. [まとめ](#まとめ)

---

## 提案概要

### 提案の目的

本提案は、AIを活用したドキュメントからの情報抽出において、**2段階の処理に分離する方式**を導入することで、抽出精度の向上と保守性の改善を実現するものです。

従来の単純推定方式では、すべての情報を一度のAI推論で抽出しようとするため、複雑なドキュメントでは精度が低下する課題がありました。本提案では、**カテゴリ判定**と**情報抽出**を分離し、カテゴリに特化したプロンプトを動的に生成することで、より高精度な抽出を実現します。

### 提案の核心

**「カテゴリ判定 → カテゴリ特化型情報抽出」という2段階の処理により、各ステップで最適化されたプロンプトを使用することで、抽出精度を大幅に向上させる**

---

## 現状の課題

### 課題1: 抽出精度の低下

**問題点**:
- 複雑なドキュメントでは、一度にすべての情報を抽出することが困難
- カテゴリごとに最適なプロンプトを適用できない
- 抽出すべきフィールドの選択が不適切になる

**具体例**:
- サーバー情報とクレジットカード情報が混在するドキュメントで、どちらも不完全に抽出される
- 金融サービスとデジタルサービスで異なるフィールドが必要だが、統一プロンプトでは対応できない

### 課題2: 保守性の低さ

**問題点**:
- 新しいカテゴリを追加する際、コードの修正が必要
- プロンプトの調整がコードベースに依存し、柔軟性が低い
- 型定義とマッピングルールの二重管理が必要

**具体例**:
- 新しいサービスカテゴリ（例: 仮想通貨取引所）を追加する際、Swiftコードの修正が必要
- プロンプトの微調整のために、アプリの再ビルド・再配布が必要

### 課題3: 拡張性の限界

**問題点**:
- カテゴリ数が増えると、コードの複雑性が指数関数的に増加
- 各カテゴリに最適化されたプロンプトを手動で管理する必要がある
- 多言語対応（日本語・英語）のプロンプトを個別に管理する必要がある

---

## 提案する手法の概念

### 基本コンセプト

**「分割推定方式」**: 情報抽出を2つのステップに分離し、各ステップで最適化された処理を実行する

```
従来方式（単純推定）:
  ドキュメント → [一度のAI推論] → アカウント情報

提案方式（2ステップ抽出）:
  ドキュメント → [Step 1: カテゴリ判定] → カテゴリ情報
                              ↓
  ドキュメント + カテゴリ情報 → [Step 2: カテゴリ特化型抽出] → アカウント情報
```

### 2層カテゴリ構造

カテゴリを2層構造で管理することで、柔軟性と精度を両立：

**第1層: メインカテゴリ（5分類）**
- 個人生活、金融・決済、デジタルサービス、仕事・ビジネス、インフラ・公的

**第2層: サブカテゴリ（25分類）**
- 各メインカテゴリに5つのサブカテゴリを定義
- 例: 仕事・ビジネス → サーバー・VPS、業務SaaS、開発ツール、ビジネスコミュニケーション、その他業務

### 動的プロンプト生成の仕組み

**JSON定義ファイルベースの動的構築**:
- カテゴリ定義、フィールド定義、マッピングルールをJSONファイルで管理
- 実行時にJSONファイルを読み込み、プロンプトを動的に生成
- 型定義不要で、柔軟な拡張が可能

**Single Source of Truth**:
- カテゴリ定義、フィールド定義、マッピングルールを1つのJSONファイルで統合管理
- コード修正なしで、定義ファイルの編集のみで対応可能

---

## 処理フロー

### 全体フロー

```
┌─────────────────────────────────────────────────────────┐
│                   入力: ドキュメント（テキスト）          │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   Step 1: カテゴリ判定         │
        │   （2層構造の判定）             │
        └───────────┬───────────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
┌───────────────┐      ┌───────────────┐
│ Step 1a:      │      │ Step 1b:      │
│ メインカテゴリ │      │ サブカテゴリ   │
│ 判定          │      │ 判定          │
│ (5分類)       │      │ (25分類)       │
└───────┬───────┘      └───────┬───────┘
        │                       │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────────────┐
        │   ContentInfo                  │
        │   - mainCategory               │
        │   - subCategory                │
        └───────────┬───────────────────┘
                    │
                    ▼
        ┌───────────────────────────────┐
        │   Step 2: アカウント情報抽出   │
        │   （カテゴリ特化型プロンプト）   │
        └───────────┬───────────────────┘
                    │
                    ▼
        ┌───────────────────────────────┐
        │   出力: AccountInfo            │
        │   （統一フォーマット）          │
        └───────────────────────────────┘
```

### Step 1: カテゴリ判定の詳細

#### Step 1a: メインカテゴリ判定

**処理内容**:
1. ドキュメントの内容を分析
2. 5つのメインカテゴリのうち、最も適切なものを判定
3. 判定結果を文字列形式で返す（例: `"work"`, `"financial"`）

**判定対象**:
- 個人生活、金融・決済、デジタルサービス、仕事・ビジネス、インフラ・公的

#### Step 1b: サブカテゴリ判定

**処理内容**:
1. Step 1aで判定されたメインカテゴリに基づき、該当する5つのサブカテゴリ候補を取得
2. ドキュメントの内容を分析
3. 25個のサブカテゴリのうち、最も適切なものを判定
4. 判定結果を文字列形式で返す（例: `"workServer"`, `"financialCreditCard"`）

### Step 2: アカウント情報抽出の詳細

**処理内容**:
1. Step 1で判定されたサブカテゴリに基づき、JSON定義ファイルから以下を読み込み:
   - サブカテゴリの説明
   - 抽出すべきフィールドの定義（名前、説明、必須/任意）
   - マッピングルール（AccountInfoへの変換ルール）
2. 読み込んだ情報を基に、カテゴリ特化型のプロンプトを動的に生成
3. 生成されたプロンプトでAI推論を実行
4. 抽出結果（汎用JSON辞書）をマッピングルールに従ってAccountInfoに変換

**動的プロンプト生成の例**:
- サーバー情報の場合: サービス名、ログインID、パスワード、ホスト、ポート、SSH鍵などのフィールドを抽出
- クレジットカード情報の場合: カード名、カード番号、有効期限、セキュリティコードなどのフィールドを抽出

---

## メリット

### メリット1: 抽出精度の向上

**効果**:
- カテゴリに特化したプロンプトを使用することで、各カテゴリで最適化された抽出が可能
- 2段階の判定により、より正確なカテゴリ判定が実現
- カテゴリごとに必要なフィールドのみを抽出することで、ノイズを削減

**具体例**:
- サーバー情報の抽出では、ホスト、ポート、SSH鍵などの技術的な情報に焦点を当てたプロンプトを使用
- クレジットカード情報の抽出では、カード番号、有効期限、セキュリティコードなどの金融情報に焦点を当てたプロンプトを使用

### メリット2: 保守性の大幅な向上（JSONによる動的構築）

**効果**:
- **コード修正不要**: 新しいカテゴリやフィールドを追加する際、JSON定義ファイルを編集するだけで対応可能
- **プロンプト調整の柔軟性**: プロンプトの改善や調整を、コードベースに触れることなく実行可能
- **Airでの実行が可能**: JSON定義ファイルの編集により、新しいフォーマットやカテゴリへの対応、プロンプトの調整などを、アプリの再ビルド・再配布なしで実現

**具体例**:
- 新しいサービスカテゴリ（例: 仮想通貨取引所）を追加する場合:
  1. 新しいサブカテゴリ定義ファイル（JSON）を作成
  2. カテゴリ定義ファイル（JSON）に新しいサブカテゴリを追加
  3. アプリの再ビルド・再配布は不要（定義ファイルのみを更新）

- プロンプトの改善が必要な場合:
  1. カテゴリ定義ファイル内のプロンプトテンプレートを編集
  2. アプリの再ビルド・再配布は不要（定義ファイルのみを更新）

- 新しいフィールドを追加する場合:
  1. サブカテゴリ定義ファイル内の`mapping`構造に新しいフィールドを追加
  2. アプリの再ビルド・再配布は不要（定義ファイルのみを更新）

### メリット3: 拡張性の向上

**効果**:
- 型定義不要: JSON方式により、動的にフィールドを管理
- カテゴリ数の増加に柔軟に対応: 新しいカテゴリを追加する際、定義ファイルを1つ追加するだけで対応可能
- 多言語対応の容易さ: 日本語・英語のプロンプトを定義ファイル内で管理し、動的に切り替え

**具体例**:
- 25個のサブカテゴリから50個に拡張する場合:
  - 新しいサブカテゴリ定義ファイル（25個）を作成
  - カテゴリ定義ファイルに新しいサブカテゴリを追加
  - コード修正は不要

### メリット4: Single Source of Truthの実現

**効果**:
- カテゴリ定義、フィールド定義、マッピングルールを1つのJSONファイルで統合管理
- 二重管理の排除: 型定義とマッピングルールを別々に管理する必要がない
- 一貫性の保証: 定義ファイルとプロンプトの内容が自動的に同期

**具体例**:
- 従来方式: Swift構造体（25個）+ マッピングルールファイル（25個）= 50個のファイルを管理
- 提案方式: サブカテゴリ定義ファイル（25個）のみを管理

### メリット5: トレーサビリティの向上

**効果**:
- カテゴリ判定結果を明示的に記録
- どのカテゴリで抽出されたかを追跡可能
- カテゴリ別の精度分析が可能

**具体例**:
- ログに`mainCategory: "work"`, `subCategory: "workServer"`を記録
- カテゴリ別の抽出精度を分析し、改善点を特定

### メリット6: 開発効率の向上

**効果**:
- 新しいカテゴリの追加が容易: 定義ファイルを1つ作成するだけで対応可能
- プロンプトの改善が迅速: 定義ファイルを編集するだけで、即座に反映可能
- テストの容易さ: カテゴリごとに独立してテスト可能

---

## デメリット

### デメリット1: 処理時間の増加

**影響**:
- 2段階の処理により、従来方式と比較して処理時間が増加する可能性
- Step 1（カテゴリ判定）で追加のAI推論が必要

**対策**:
- Step 1の処理時間は平均2-3秒程度と短時間
- カテゴリ定義ファイルのキャッシュにより、読み込み時間を最小化
- 精度向上による再抽出の削減により、総合的な効率が向上する可能性

**評価**:
- 処理時間の増加（約2-3秒）と精度向上のトレードオフを考慮
- 高精度な抽出により、後続処理の効率化が期待できる

### デメリット2: システムの複雑性の増加

**影響**:
- 2段階の処理により、システムの複雑性が増加
- エラーハンドリングが複雑になる可能性

**対策**:
- 各ステップで明確なエラーハンドリングを実装
- 詳細なログ出力により、問題の特定を容易に
- 段階的なロールアウトにより、リスクを最小化

**評価**:
- 複雑性の増加は、保守性の向上（JSON定義ファイルベース）により相殺される
- 動的プロンプト生成により、コードの複雑性はむしろ減少

### デメリット3: カテゴリ判定の誤りによる影響

**影響**:
- Step 1でカテゴリを誤判定した場合、Step 2で不適切なプロンプトが使用される
- 誤判定により、抽出精度が低下する可能性

**対策**:
- 2層構造のカテゴリ判定により、より正確な判定を実現
- カテゴリ定義ファイルに豊富な例を記載し、判定精度を向上
- カテゴリ判定結果をログに記録し、問題を特定・改善

**評価**:
- カテゴリ判定の精度は、豊富な例と明確な定義により高精度を実現
- 誤判定が発生した場合でも、ログにより迅速に改善可能

### デメリット4: 定義ファイルの管理コスト

**影響**:
- 25個のサブカテゴリ定義ファイルを管理する必要がある
- 定義ファイルの整合性を保つ必要がある

**対策**:
- 定義ファイルのテンプレート化により、作成・編集を容易に
- バリデーション機能により、定義ファイルの整合性を保証
- ドキュメント化により、定義ファイルの管理方法を明確化

**評価**:
- 定義ファイルの管理コストは、コード修正の削減により相殺される
- JSON形式により、人間が読み書きしやすい形式で管理可能

### デメリット5: 初期実装コスト

**影響**:
- 2段階の処理を実装するための初期コストが必要
- カテゴリ定義ファイルの作成に時間がかかる

**対策**:
- 段階的な実装により、リスクを最小化
- テンプレートを提供し、定義ファイルの作成を容易に
- 既存の単純推定方式との併用により、段階的な移行が可能

**評価**:
- 初期実装コストは、長期的な保守性の向上により回収可能
- 動的プロンプト生成により、将来的な拡張コストが削減される

---

## 適用シーン

### 適用が適しているケース

#### ケース1: 多様なカテゴリの情報を扱う場合

**特徴**:
- サーバー情報、クレジットカード情報、サブスクリプション情報など、異なるカテゴリの情報を扱う
- 各カテゴリで必要なフィールドが異なる

**効果**:
- カテゴリごとに最適化されたプロンプトにより、高精度な抽出が可能
- 新しいカテゴリの追加が容易

#### ケース2: 頻繁にプロンプトを調整する必要がある場合

**特徴**:
- AIモデルの更新や、抽出要件の変更により、プロンプトの調整が必要
- アプリの再ビルド・再配布を避けたい

**効果**:
- JSON定義ファイルの編集により、プロンプトを即座に調整可能
- Airでの実行により、アプリの再ビルド・再配布なしで対応可能

#### ケース3: 新しいサービスやフォーマットへの対応が必要な場合

**特徴**:
- 新しいサービスカテゴリ（例: 仮想通貨取引所、新しいSaaSサービス）への対応が必要
- 新しいフィールド（例: APIキー、2要素認証コード）への対応が必要

**効果**:
- 新しいサブカテゴリ定義ファイルを作成するだけで対応可能
- コード修正不要で、迅速に対応可能

#### ケース4: カテゴリ別の精度分析が必要な場合

**特徴**:
- どのカテゴリで抽出精度が低いかを分析したい
- カテゴリごとに改善施策を実施したい

**効果**:
- カテゴリ判定結果をログに記録し、カテゴリ別の精度分析が可能
- カテゴリごとに独立してプロンプトを改善可能

### 適用が適していないケース

#### ケース1: 単一カテゴリのみを扱う場合

**特徴**:
- 特定のカテゴリ（例: サーバー情報のみ）を扱う
- カテゴリ判定が不要

**評価**:
- 2ステップ抽出のメリットが限定的
- 単純推定方式で十分な場合がある

#### ケース2: 処理時間が厳しく制約される場合

**特徴**:
- リアルタイム処理が必要
- 処理時間の増加が許容できない

**評価**:
- 2段階の処理により、処理時間が増加する可能性
- 精度向上とのトレードオフを考慮

---

## まとめ

### 提案の価値

本提案の2ステップ抽出方式は、以下の価値を提供します：

1. **抽出精度の向上**: カテゴリに特化したプロンプトにより、高精度な抽出を実現
2. **保守性の大幅な向上**: JSON定義ファイルベースの動的構築により、コード修正不要で対応可能
3. **Airでの実行が可能**: 新しいフォーマットやカテゴリへの対応、プロンプトの調整などを、アプリの再ビルド・再配布なしで実現
4. **拡張性の向上**: 型定義不要で、柔軟な拡張が可能
5. **Single Source of Truth**: 定義ファイルの統合管理により、一貫性を保証

### 推奨事項

**段階的な導入を推奨**:
1. **フェーズ1**: 主要なカテゴリ（例: サーバー情報、クレジットカード情報）で実証
2. **フェーズ2**: 全25カテゴリへの展開
3. **フェーズ3**: プロンプトの最適化と精度向上

**成功の鍵**:
- カテゴリ定義ファイルの品質: 豊富な例と明確な定義
- プロンプトの継続的な改善: 抽出結果を分析し、プロンプトを改善
- 定義ファイルの管理: テンプレート化とバリデーション機能の活用

### 期待される効果

- **短期**: 抽出精度の向上（10-20%の改善を期待）
- **中期**: 保守性の向上による開発効率の向上（新しいカテゴリ追加時間の50%削減）
- **長期**: Airでの実行による運用効率の向上（アプリの再ビルド・再配布の削減）

---

**最終更新日**: 2025-11-15 16:14
**提案者**: プロジェクトチーム

